# data lab

## bitAnd(int x, int y)

- 用离散的公式就好了
- ~(~x | ~y)

## getByte(int x, int n)

- 获取n偏移处的字节
- 从0开始每增加1就会导致移位增加8
- 最后用移位后的数与0xff进行与运算屏蔽掉高位信息就好了

## logical shift

- 逻辑右移，就是高位皆用0填充
- 通过算数右移之后高位会用最高有效位填充，所以我们想实现逻辑右移只要把被填充的位 置0就好
- 我们通过把1挪到最高位，然后通过算数右移挪动对应的位数，这样原数据通过算数右移带出来的最高有效位就被1覆盖了
- 但是这样会覆盖到原数据右移前的最高有效位，我们只要再左移一位然后取反，得到的新数记位x
- 原数据进行算数右移后被最高有效位覆盖的位对应到x都是0，所以只要和x进行与运算就消除了算数右移带来的影响

## bit count

- 挺难的，正在看别人的答案

## bang

- 0是全0，非0在数据位里一定有1存在
- 只要能抽出这个1然后挪到最低位再取反，然后和1进行与运算就得到了！运算符的结果

## tmin

- 找最小数，很简单，直接左移31位

## firstBits

- x是否能用n位数据表示，在n位能表示的情况下
- 对于非负数，只能在他的n-1位里有1
- 对于负数，只能n-1位里有0
- 那么我们我们算数右移n-1位后，负数就会变成全1，正数就会变成全0
- 所以我们右移n-1位后加1，然后再右移1位，这样所有位都变成0了
- 然后再进行一次非运算，对n位可以表示的数返回true了。

## divpwr2

- 如果是正数，直接右移就好
- 如果是负数，在做除法的时候是向上取整的，这时候直接右移就不行了，要加上一个offset修正
- 这个offset我不是很理解 : 2^n - 1，也没找到相关证明。

## negate

- 算补码就好
- 按位取反加1

## isPositive

- 是否是正数，大于0就返回1，其余返回0
- 如果是正数，那么符号位一定为0
- 负数的符号位一定为1
- 左移31位后就可以提取出符号位的信息
- 进行一次非运算后针对正数就可以返回1了
- 但是对于0来说有问题，我们需要用和!x的或运算修正一下
- 这样!((x >> 31 & 1) | (!x))就可以修正0的情况，因为!0会返回非0，然后或运算后就被修正成1，然后再进行!运算就修正了结果

## islessOrEqual

- 比较两个数字
- 如果符号相同直接进行相减就好
- 符号不同的话可能会溢出，所以要做修正
- 针对符号不同
  - x是负数，那么一定返回1
  - x是正数，那么一定返回0
  - 可以写出如下逻辑表达式: (singx ^ signy) & signx

- 可以写出如下逻辑表达式
  - ((y + (~x + 1)) >> 31) & 1

- 所以整个可以这样写

## ilog2

- 这个就是返回x最高位的1在哪里的
- 1.判断前16位有没有1，如果有则丢弃后16位，继续运算
- 2.判断新的数前8位有没有1，有就丢弃后8位
- 3.判断前4位有没有1，有就丢弃后4位
- 4.判断前2位有没有1，有就丢弃后2位
- 5.判断前1位有没有1，然后就可以计算结果了
- 用了分治法，学到了

## 浮点数部分

## float_neg

- 首先屏蔽掉符号位，提取出符号位之外的位信息
- 然后通过与0x80000000异或对符号位取反，这么做除了符号位之外的位也都被保留了
- 然后做个判断，如果是NaN，就直接返回本身，不是的话就返回上一步的数据就可以了

## float_i2f

- 首先判断正负，保留符号位
- 然后进行左移，直到最高有效位为1，这样我们把这部分的数视作尾数，并且记录下移动的次数n
- 这样它的幂次就是(32 - n)，因为把左移n位后的数据xxxxxx00000000000视作尾数的话，那就是0.xxxx，用32减去移动的位数n就是原数据的位数，根据单精度浮点数的计算规则，得出阶码等于数据的位数+127，还原数据是0.xxxxxxx * （阶码 - 127）
- 然后根据左移后的余下数据来判断是否需要进位，因为尾数有可能超出23位，所以要进行四舍五入来抛弃掉后面的，只保留最前的23位。
- 然后根据之前算出来的阶码、尾数、进位、符号位进行整合就得到了单精度浮点数(IEEE754标准)

## float_twice

- 判断是否是无穷大和NaN，是的话就直接返回原数
- 针对规格化的数，也就是阶码不为0
  - 直接阶码+1就好

- 针对非规格化数，也就是阶码为0
  - 直接对尾数左移一位就好
