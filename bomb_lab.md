# bomb lab

由于我mac虚拟机有点问题，不能拖放文件，只能用windows下的虚拟机做了，这篇笔记没截图，见谅(其实是为了windows的pwndbg，这个调试器太好用了，强烈安利)

## phase1

- 断在phase1处，发现在phase1里出现了string_not_equal函数，然后根据这个函数的返回值判断是否引爆炸弹
- 这个函数的两个参数分别是用户自己输入的字符串，第二个是一个藏在指令段的字符串，猜测可能是这两个字符串相等就可以了
- 跟进string_not_equal函数，发现首先计算了两个字符串的长度，如果不相等就炸，接下来就是比较两个字符串的汇编了，所以我猜测是对的
- 那么我们只要输入那个字符串就好了 'Border relations with Canada have been better'

## phase2

- 断在phase2处，发现read_six_numbers函数，可以猜到是读取六个数字，然后观察函数的参数是栈顶指针，可以推断输入的数字是存在栈上的
- 后面的汇编可以推断出，第一个数💊是1，然后之后的每个数都是前面的数的2倍
- 所以我们只要输入1 2 4 8 16 32

## phase3

- 断在phase3处，发现了scanf，看到格式化字符串是“%d %d”,可以得出是输入两个整数，然后看一下scanf的返回值是否正常，不正常就引爆炸弹，然后判断输入的第一个是否大于等于7，符合就引爆炸弹，推断出第一个数是小于7的
- 程序维护了一个跳表。接下来的汇编是根据输入的第一个数去跳转到对应指令
- 观察完后面的代码，第一个数和第二个数是有对应关系的，比如0就对应了0xcf，后面根据第一个数去取对应的数，然后比较第二个数是否和取出的数相等
- 所以只要输入0和207就可以了

## phase4

- 断在phase4处，发现还是通过scanf输入两个数
- 发现中间执行了一次func4，要确保这个函数的返回值是0，然后输入的第二个数为0才能不引爆炸弹
- func4的三个参数分别是number1，0x0，0xe，进func4看一下
- 有可能是个递归函数，因为发生了两次比较，满足某种条件就会递归调用func4，继续看，发现只要卡着相等的那个条件就可以跳过递归直接让func4返回0，所以接下来是看一下ecx寄存器的值
- 根据指令推算出ecx的值是 (0xe >> 1) + 0  = 7 //第一次进入函数
- 所以number1一定是7，第二个数是0

## phase5

- 断在phase5处，发现这个还有canary(滑稽)，首先确认我们输入的字符串长度是否是6，不是就引爆炸弹
- 然后对输入的字符串进行了一波处理，是个循环，针对输入的六个字符
- 然后把处理后的字符串和另一个字符串进行比较，如果相等就可以
- 接下来看下处理过程。首先每个字节取后四位，然后根据这个后四位取04024b0对应偏移处的字符再存回去
- 观察对应内存处的值，开头是乱序的字符，后面一句话So you think you can stop....(后面省略)
- 看看最终要比较的字符串 "flyers"
- 这样只要去查每个字符对应的偏移就好了，然后这个偏移只是后四位，所以要根据这个后四位取反推原先可见的ascii字符

## phase6

- phase6还挺长的，首先还是读了六个数
- 阅读后面的代码，大致意思就是这六个数每个都要小于等于6，并且不能相同
- 然后用7分别和这六个数做减法
- 然后在栈上存储根据输入的数字算出对应node结点的地址
- 接下来的操作是把这些结点连起来
- 后面的代码是判断连起来的node的数据域是否是递减的，所以通过查看各个node的数据域拿到结点下标的序列
- 然后因为减7了，所以还要再还原一下
- 序列就是4 3 2 1 6 5

## sumaary

- 感觉这几个题都不是很难，直接dump出汇编代码去看就好了，配合一点点调试，